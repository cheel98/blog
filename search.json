[{"title":"浅谈sync.Pool","url":"/blog/posts/73dd0434/","content":"顾名思义,sync.Pool是一个线程安全的池，池子里放的是一些可以复用的变量，利用sync.Pool可以有效减少GC和内存分配次数。\n<!--more-->\n## 1 适用场景\n对象创建/销毁多，但更新少\n\n## 2 使用方法\n\n### 2.1 声明对象池\n\n只需要实现 New 函数即可。对象池中没有对象时，将会调用 New 函数创建。\n\n``` golang \nvar studentPool = sync.Pool{\n\tNew: func() interface{} { \n   \t return new(Student)        \n   },\n}\n```\n\n### 2.2 Get & Put\n\n```golang\nstu := studentPool.Get().(\\*Student)   \njson.Unmarshal(buf, stu)   \nstudentPool.Put(stu) \n```\n- `Get()` 用于从对象池中获取对象，因为返回值是 `interface{}`，因此需要类型转换。\n- `Put()` 则是在对象使用完毕后，返回对象池。\n\n### 2.3 测试\n\n```golang\nfunc BenchmarkUnmarshal(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tstu := &Student{}\n\t\tjson.Unmarshal(buf, stu)\n\t}\n}\n\nfunc BenchmarkUnmarshalWithPool(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tstu := studentPool.Get().(*Student)\n\t\tjson.Unmarshal(buf, stu)\n\t\tstudentPool.Put(stu)\n\t}\n}\n```\n\n这个例子中只是将sync.Pool中的对象读取，并没有将对象更改。\n\n## 3 bytes.Buffer\n\n```golang\nvar bufferPool = sync.Pool{\n\tNew: func() interface{} {\n\t\treturn &bytes.Buffer{}\n\t},\n}\n\nvar data = make([]byte, 10000)\n\nfunc BenchmarkBufferWithPool(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tbuf := bufferPool.Get().(*bytes.Buffer)\n\t\tbuf.Write(data)\n\t\tbuf.Reset()\n\t\tbufferPool.Put(buf)\n\t}\n}\n\nfunc BenchmarkBuffer(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tvar buf bytes.Buffer\n\t\tbuf.Write(data)\n\t}\n}\n```\n\n从pool中取出buffer并使用后，不要忘记reset操作\n\n## fmt\n\n在golang的fmt源码中使用了pool。\n"},{"title":"Golang 切片的扩容机制","url":"/blog/posts/f7b21975/","content":"介绍一下golang中切片的复制，扩容等机制。\n<!-- more-->\n## slice底层结构\n\n```golang\ntype slice struct {\n    ptr *T       // 指向底层数组的指针\n    len int      // 当前元素数\n    cap int      // 容量（数组大小）\n}\n```\n\n\n### 扩容\n\n\nv1.8 之前新容量的计算规则如下： \n- 需要的容量比2倍容量大：使用需要的容量 \n  - 一般发生于append一个较大的slice时，例如 append(s, s1...)   \n\n- 如果原容量小于1024，按照2倍扩容  \n- 如果原容量大于等于1024，按照1.25倍扩容，对应源码newcap += newcap / 4  \n- 如果newcap溢出了int最大值，不扩容\n\n最新的扩容规则为：\n\n- 需要的容量比2倍原容量大：使用需要的容量\n- 如果原容量小于256， 2倍扩容\n- 如果原容量大于等于256，newcap = 1.25倍的newcap + 192 计算新的容量直到大于所需容量\n- 溢出则报panic\n- 计算出新的cap之后，还需要进行内存对齐。\n\n\n#### 源码 （v1.24.1）\n\n```golang\n/**\noldPtr\t原切片底层数组的指针\nnewLen\t扩容后的长度（=旧长度 + 新添加元素数量）\noldCap\t原切片的容量\nnum\t要添加的元素数量\net\t元素类型 _type（用于确定大小、是否包含指针等）\n*/\nfunc growslice(oldPtr unsafe.Pointer, newLen, oldCap, num int, et *_type) slice {\n\t...\n\tnewcap := nextslicecap(newLen, oldCap)\n\tswitch {\n\tcase et.Size_ == 1:\n\t\tlenmem = uintptr(oldLen)\n\t\tnewlenmem = uintptr(newLen)\n\t\tcapmem = roundupsize(uintptr(newcap), noscan)\n\t\toverflow = uintptr(newcap) > maxAlloc\n\t\tnewcap = int(capmem)\n\tcase et.Size_ == goarch.PtrSize:\n\t\t...\n\tcase isPowerOfTwo(et.Size_):\n\t\t...\n\tdefault:\n\t\t...\n\t}\n\t...\n\treturn slice{p, newLen, newcap}\n}\n\nfunc nextslicecap(newLen, oldCap int) int {\n\tnewcap := oldCap\n\tdoublecap := newcap + newcap\n\tif newLen > doublecap {\n\t\treturn newLen // 如果两倍的原cap 仍然不足以放下新的元素，则直接使用 旧长度 + 新添加元素数量\n\t}\n\n\tconst threshold = 256\n\tif oldCap < threshold {\n\t\treturn doublecap // 如果原cap 小于256 则扩容倍数为2\n\t}\n\tfor {\n        // 等价于 newcap = 1.25倍的newcap + 192\n\t\tnewcap += (newcap + 3*threshold) >> 2\n\n\t\tif uint(newcap) >= uint(newLen) {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif newcap <= 0 {\n\t\treturn newLen\n\t}\n\treturn newcap\n}\n\n// 内存对齐\nfunc roundupsize(size uintptr, noscan bool) (reqSize uintptr) {\n\treqSize = size\n\tif reqSize <= maxSmallSize-mallocHeaderSize {\n\t\tif !noscan && reqSize > minSizeForMallocHeader { \n\t\t\treqSize += mallocHeaderSize\n\t\t}\n\t\tif reqSize <= smallSizeMax-8 {\n\t\t\treturn uintptr(class_to_size[size_to_class8[divRoundUp(reqSize, smallSizeDiv)]]) - (reqSize - size)\n\t\t}\n\t\treturn uintptr(class_to_size[size_to_class128[divRoundUp(reqSize-smallSizeMax, largeSizeDiv)]]) - (reqSize - size)\n\t}\n\t// Large object. Align reqSize up to the next page. Check for overflow.\n\treqSize += pageSize - 1\n\tif reqSize < size {\n\t\treturn size\n\t}\n\treturn reqSize &^ (pageSize - 1)\n}\n```\n### 注意事项\n\n1. 进行大容量的合并时，避免使用golang自动扩容（append方法），而是使用预留cap和copy方法\n\n\n### 内存对齐\n\n#### 提高访问速率\n\n如 \n```golang \ntype dog struct {\n\tage uint8\n   balance uint64\n}\n```\n定义一个新的dog对象后, age 占8位，balance 占64位，在64位的操作系统中,通过```fmt.Println(unsafe.Sizeof(Args{}))``` 输出结果位16, 但我们可以看到结构体其实只有(8+64)/8=9 位，其与7位即内存对齐的效果。\n\n在没有内存对齐之前，64位操作系统一次可以读取8个字节,在读取balance时需要进行两次内存读取。\n内存对齐之后，只需要进行一次内存读取。"},{"title":"面试经历","url":"/blog/posts/892a2328/","content":"\n我是一个面试golang开发的工程师，开发方向是区块链。你从一个专业的golang开发，区块链开发来对我进行面试\n\n<!-- more -->\n### **第一部分：Golang 基础与进阶**\n\n1. Golang并发模型\n\n   在Golang中，goroutine和channel是并发编程的核心。请详细讲解goroutine和channel的工作原理，并举例说明如何使用它们实现一个生产者-消费者模型。\n\n2. Golang内存管理\n\n   Golang的垃圾回收机制是如何工作的？在高性能区块链应用中，如何优化Golang程序以减少GC的开销？\n\n3. Golang接口与反射\n\n   在Golang中，interface是如何实现的？在区块链开发中，interface和反射可能在哪些场景中使用？请举例说明。\n\n------\n\n### **第二部分：区块链开发相关**\n\n1. 区块链基础\n\n   请解释区块链的工作原理，重点说明共识机制（如PoW、PoS）的核心思想。如果让你用Golang实现一个简单的PoW共识机制，你会如何设计？\n\n2. 智能合约开发\n\n   在以太坊的智能合约开发中，Solidity是最常用的语言。如果需要用Golang与以太坊智能合约交互，你会使用哪些库？请描述调用智能合约的流程。\n\n3. 区块链性能优化\n\n   假设你在开发一个高吞吐量的公链，节点需要处理大量交易。如何用Golang优化区块链节点的性能？\n\n------\n\n### **第三部分：工程实践与问题解决**\n\n1. 分布式系统设计\n\n   区块链本质是一个分布式系统。在Golang中实现一个P2P网络节点时，如何处理节点发现、消息广播和网络分区问题？\n\n2. 错误处理与日志\n\n   在区块链开发中，错误处理和日志记录尤为重要。请分享你在Golang项目中如何设计错误处理机制和日志系统？\n\n3. 实际问题解决\n\n   假设你开发的区块链节点在高负载下频繁出现内存泄漏问题，你会如何定位和解决？请描述你的排查流程和可能的原因。\n\n------\n\n### **第四部分：开放性问题**\n\n1. 系统设计\n\n   假设你要用Golang开发一个去中心化的NFT交易平台，包含链上NFT铸造和链下交易撮合功能。请简要设计系统架构，并说明Golang在其中的关键作用。"},{"title":"欢迎体验我的博客","url":"/blog/posts/cf92dd80/","content":"\n## 欢迎来到我的博客！\n\n这是我的第一篇文章，感谢使用Hexo搭建的个人博客。未来我会分享更多关于技术、生活和思考的内容。\n\n<!-- more -->\n\n## 为什么建博客？\n\n* 记录学习历程\n* 分享技术经验\n* 与大家交流想法\n* 期待你的评论！","tags":["博客","欢迎"],"categories":["生活"]}]